name: Generate Version and Build Artifacts

# This workflow will run on every push to the 'main' branch.
on:
  push:
    branches:
      - main

jobs:
  build:
    # Specifies the runner environment. 'ubuntu-latest' is a common choice.
    runs-on: ubuntu-latest

    steps:
    # Step 1: Checkout the repository code.
    # This action checks out your repository under $GITHUB_WORKSPACE,
    # so your workflow can access it.
    - name: Checkout repository
      uses: actions/checkout@v4

    # Step 2: Generate the version string.
    # It combines the current date (YYMMDD) and a 2-digit run number.
    # The run number is taken from GITHUB_RUN_NUMBER and modulo 100 to ensure it's 2 digits,
    # then padded with a leading zero if necessary.
    - name: Get current date and run number for versioning
      id: version_info # Assigns an ID to this step to reference its outputs later.
      run: |
        # Get the current date in YYMMDD format.
        DATE_CODE=$(date +'%y%m%d')
        echo "Current Date Code: ${DATE_CODE}"

        # Get the GitHub run number. This is a unique, incrementing number for each workflow run.
        # We take the run number modulo 100 to get a value between 0 and 99,
        # then format it to be always 2 digits with leading zeros (e.g., 1 -> 01, 15 -> 15).
        # This acts as your "number of pushes" component, cycling every 100 pushes.
        RUN_NUMBER_PADDED=$(printf "%02d" $((GITHUB_RUN_NUMBER % 100)))
        echo "Padded Run Number: ${RUN_NUMBER_PADDED}"

        # Combine date and run number to form the full version string.
        VERSION_STRING="${DATE_CODE}${RUN_NUMBER_PADDED}"
        echo "Generated Version String: ${VERSION_STRING}"

        # Set the VERSION_STRING as an output of this step, so other steps can use it.
        echo "VERSION_STRING=${VERSION_STRING}" >> $GITHUB_OUTPUT

    # Step 3: Create the test_version.txt file with the generated version string.
    - name: Create test_version.txt
      run: |
        echo "${{ steps.version_info.outputs.VERSION_STRING }}" > test_version.txt
        echo "Content of test_version.txt:"
        cat test_version.txt # Display the content for verification in the workflow logs.

    # Step 4: Simulate your build process.
    # Replace these commands with your actual build commands (e.g., npm install, npm run build, mvn package, python setup.py install, etc.).
    # This example creates a directory and some dummy files.
    - name: Simulate a full build process
      run: |
        echo "Starting the build process..."
        mkdir -p build_output # Create a directory for build artifacts.
        echo "This is a dummy build artifact file 1." > build_output/app.js
        echo "This is a dummy build artifact file 2." > build_output/styles.css
        echo "Build process completed successfully."

    # Step 5: Upload the generated build artifacts.
    # The 'actions/upload-artifact' action saves files generated by your workflow.
    # These artifacts can be downloaded from the workflow run summary page.
    - name: Upload build artifacts
      uses: actions/upload-artifact@v4
      with:
        name: full-build-artifacts # Name of the artifact.
        path: build_output/       # Path to the directory containing artifacts.

